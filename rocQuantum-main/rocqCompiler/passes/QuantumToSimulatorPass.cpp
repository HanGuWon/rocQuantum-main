#include "mlir/Pass/Pass.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/IR/Builders.h"

// These are the headers that would be generated by tblgen
#include "QuantumOps.h.inc"
#include "SimulatorOps.h.inc"

namespace {

// Generic lowering pattern for simple, non-parametrized gates
template <typename SourceOp>
struct GateLoweringPattern : public mlir::OpRewritePattern<SourceOp> {
    using mlir::OpRewritePattern<SourceOp>::OpRewritePattern;
    
    GateLoweringPattern(mlir::MLIRContext *context, std::string gate_name)
        : mlir::OpRewritePattern<SourceOp>(context), gate_name(std::move(gate_name)) {}

    mlir::LogicalResult matchAndRewrite(SourceOp op, mlir::PatternRewriter &rewriter) const override {
        rewriter.replaceOpWithNewOp<rocq::mlir::sim::ApplyGateOp>(
            op, rewriter.getStringAttr(gate_name), op->getOperands());
        return mlir::LogicalResult::success();
    }
private:
    std::string gate_name;
};

// Lowering pattern for parametric single-qubit gates that carry an `angle` attr.
template <typename SourceOp>
struct ParamGateLoweringPattern : public mlir::OpRewritePattern<SourceOp> {
    using mlir::OpRewritePattern<SourceOp>::OpRewritePattern;

    ParamGateLoweringPattern(mlir::MLIRContext *context, std::string gate_name)
        : mlir::OpRewritePattern<SourceOp>(context), gate_name(std::move(gate_name)) {}

    mlir::LogicalResult matchAndRewrite(SourceOp op, mlir::PatternRewriter &rewriter) const override {
        mlir::FloatAttr angle_attr = op->template getAttrOfType<mlir::FloatAttr>("angle");
        if (!angle_attr) {
            return mlir::LogicalResult::failure();
        }

        rewriter.replaceOpWithNewOp<rocq::mlir::sim::ApplyParamGateOp>(
            op,
            rewriter.getStringAttr(gate_name),
            angle_attr,
            op->getOperands());
        return mlir::LogicalResult::success();
    }

private:
    std::string gate_name;
};

// The main pass definition
struct QuantumToSimulatorPass : public mlir::PassWrapper<QuantumToSimulatorPass, mlir::OperationPass<mlir::ModuleOp>> {
    MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumToSimulatorPass)

    void getDependentDialects(mlir::DialectRegistry &registry) const override {
        registry.insert<rocq::mlir::quantum::QuantumDialect, rocq::mlir::sim::SimulatorDialect>();
    }

    void runOnOperation() override {
        mlir::ConversionTarget target(getContext());
        target.addLegalDialect<mlir::func::FuncDialect, rocq::mlir::sim::SimulatorDialect>();
        target.addIllegalDialect<rocq::mlir::quantum::QuantumDialect>();

        mlir::RewritePatternSet patterns(&getContext());
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::HOp>>(&getContext(), "h");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::XOp>>(&getContext(), "x");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::YOp>>(&getContext(), "y");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::CnotOp>>(&getContext(), "cnot");
        patterns.add<GateLoweringPattern<rocq::mlir::quantum::ZOp>>(&getContext(), "z");
        patterns.add<ParamGateLoweringPattern<rocq::mlir::quantum::RxOp>>(&getContext(), "rx");
        patterns.add<ParamGateLoweringPattern<rocq::mlir::quantum::RyOp>>(&getContext(), "ry");
        patterns.add<ParamGateLoweringPattern<rocq::mlir::quantum::RzOp>>(&getContext(), "rz");

        if (failed(applyPartialConversion(getOperation(), target, std::move(patterns)))) {
            signalPassFailure();
        }
    }
};

} // anonymous namespace

// Factory function to create a new pass instance
std::unique_ptr<mlir::Pass> createQuantumToSimulatorPass() {
    return std::make_unique<QuantumToSimulatorPass>();
}
