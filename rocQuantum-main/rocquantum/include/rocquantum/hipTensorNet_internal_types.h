#ifndef HIP_TENSOR_NET_INTERNAL_TYPES_H
#define HIP_TENSOR_NET_INTERNAL_TYPES_H

#include "hipTensorNet_api.h" // For rocPathfinderAlgorithm_t
#include "rocTensorUtil.h" // For rocTensor
#include <vector>
#include <string>

namespace rocquantum {
namespace internal {

/**
 * @brief Represents a single pairwise contraction within a larger tensor network contraction plan.
 *
 * This struct holds metadata about the two tensors being contracted, the computational cost (FLOPs),
 * and the properties of the resulting intermediate tensor.
 */
struct ContractionStep {
    int tensor_index_1; ///< Index of the first tensor operand in the active tensor list.
    int tensor_index_2; ///< Index of the second tensor operand in the active tensor list.
    long long flops;    ///< Estimated floating-point operations for this step.

    // Metadata about the resulting intermediate tensor
    std::vector<long long> resulting_dims;   ///< Dimensions of the tensor produced by this step.
    std::vector<std::string> resulting_labels; ///< Mode labels of the tensor produced by this step.
};

/**
 * @brief Holds the complete, ordered plan for contracting a tensor network.
 *
 * This object is generated by a Pathfinder and contains the sequence of pairwise
 * contractions, along with summary statistics like total FLOPs and peak memory usage.
 */
struct ContractionPlan {
    ///< The ordered sequence of pairwise contraction steps.
    std::vector<ContractionStep> steps;

    ///< A copy of the initial tensors in the network.
    std::vector<rocquantum::util::rocTensor> initial_tensors;

    ///< The total estimated floating-point operations for the entire contraction.
    long long total_flops = 0;

    ///< The size in bytes of the largest intermediate tensor that will be created.
    long long largest_intermediate_size_bytes = 0;

    ///< The algorithm that was used to generate this plan.
    rocPathfinderAlgorithm_t algorithm;
};

} // namespace internal
} // namespace rocquantum

#endif // HIP_TENSOR_NET_INTERNAL_TYPES_H
